# General Flow for C# APIs

Class used Gateway.API with Aspire and Mertens for Session

## Config

    - Root: ./ = folder for APIs

    1. In ./Program.cs, set up DB connection and mertens connection:

[See the services page for more info on the set up to make APIs work](<10.40 - Services.md>)

        In short, you'll set up a connection string, do some configs by adding a service like Merten, build, Map endpoints (which are below), then run

    2. ./Properties/launchSettings.json

        - Settings for localhost set up

    3. ./apiFolder(The API project Students in example)/ApiExtensions.cs

        - Where you assign the routes and connect them to builder:

        - The params for the methods are (string pattern, Delegate handler).

            - Within the handler, you are mapping to the actual function. In this example it is within:
                "./apiFolder(The API project Students in example)/Endpoints/StudentAddsMoment.cs"
            - See Create Routes Below for more

## METHODS

```
            public static class ApiExtensions
            {
                extension(IEndpointRouteBuilder endpoints)
                {
                    // POST /students/moments
                    // GET /student/moments
                    public IEndpointRouteBuilder MapStudentEndpoints() 
                    {
                        // 1 hypocritical 
                        // 2 "slimed" - 
                        var group = endpoints.MapGroup("/student/moments");
                        // if any http post methods come in for /student/moments run this function
                        group.MapPost("", StudentAddsMoment.AddMoment);
                        group.MapGet("", StudentGetsListOfSavedMoments.GetAllMomentsForStudent);
                        // DELETE /student/moments/???
                        group.MapDelete("/{id:guid}", StudentMarksMomentAnswered.MarkQuestionAnswered);


                        // TODO /student/answered-questions
                        return group;
                    }
                }
            }
```

## Create Routes

    1. Example of a route using async Task, describing the object, and else:

    ```
    using Marten;
    using Microsoft.AspNetCore.Http.HttpResults;

    namespace MuddiestMoment.Api.Student.Endpoints;

    public static class StudentAddsMoment
    {
        public static async Task<Ok<StudentMomentResponseModel>> AddMoment(
            StudentMomentCreateModel request, IDocumentSession session)
        {
            var response = new StudentMomentResponseModel
            {
                Id = Guid.NewGuid(),
                Title = request.Title,
                Description = request.Description,
                CreatedOn = DateTimeOffset.UtcNow,
                AddedBy = "fake user" // TODO: We need the ID of the actual user that made this request.
            };

            // saving it to the database.
            var entity = new StudentMomentEntity
            {
                // mapping 
                Id = response.Id,
                Title = response.Title,
                Description = response.Description,
                AddedBy = response.AddedBy,
                CreatedOn = response.CreatedOn
            };

            // will vary depending on what libarary/database you are using.
            session.Store(entity); // this connection running this code wants to as part of this operation,
            // store this entity.
            // list of things that this "means" - Transaction -- all of this has to happen or none of it does.

            await session.SaveChangesAsync();


            return TypedResults.Ok(response);
        }
    }
    ```

## Running and Testing

    1. Make sure to run without debugging for now (ctl + F5)
    2. Check DB is now running and connected (open docker with this example)
    3. Test connection using http request in one of the days markdowns
        - See jeff-notes/00-Inbox/mm-api.md


## API Fetching in Angular

    1. In export class PageName {
        apiResource = httpResource<{object type}>(
            () => "https://some-api-route.url/folder
        )
    }
    2. Then you use your resource in the template of that page:

```
    import { httpResource } from '@angular/common/http';
    import { ChangeDetectionStrategy, Component } from '@angular/core';

    @Component({
    selector: 'app-basics-resource-demo',
    changeDetection: ChangeDetectionStrategy.OnPush,
    imports: [],
    template: `
        @if (todosResource.isLoading()) {
        <span class="loading loading-bars loading-xs"></span>
        <span class="loading loading-bars loading-sm"></span>
        <span class="loading loading-bars loading-md"></span>
        <span class="loading loading-bars loading-lg"></span>
        <span class="loading loading-bars loading-xl"></span>
        } @else {
        <ul>
            @for (todo of todosResource.value(); track todo.id) {
            <li>
                <strong>[{{ todo.completed ? 'x' : ' ' }}]</strong>
                {{ todo.title }}
            </li>
            }
        </ul>
        }
    `,
    styles: ``,
    })
    export class ResourceDemo {
    todosResource = httpResource<{ id: string; title: string; completed: boolean }[]>(
        () => 'https://jsonplaceholder.typicode.com/todos',
    );
    }
```

## MSWJS

    - Mock doubles for testing

## General

- TCP
        - Needs a connection between the client and the server
- UDP
        - Connection-less. Fire and forget
- Http 1.0
        - Each req/res needed a new connection
        - Only six connections at a time
- HTTP 1.1
        - Introduced "keep-alives"
- HTTP 2.0
        - (UDP)
        - Multiple requests are almost the same "cost" as a single request
- HTTP 3.0
        - 